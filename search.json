[
  {
    "objectID": "test_area_observations.html",
    "href": "test_area_observations.html",
    "title": "Test scene analysis",
    "section": "",
    "text": "Code\nimport sys\nsys.path.insert(1, '..')\n\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport pandas as pd\nimport geopandas as gpd\nfrom pathlib import Path\nimport os\nimport numpy as np\nimport rasterio as rio\nimport rasterio.plot as rio_plot\nfrom shapely.geometry import Point, Polygon\nimport shapely\n\nfrom pycocotools.coco import COCO\nfrom pycocotools.cocoeval import COCOeval\nfrom ultralytics.utils.metrics import DetMetrics\nimport fiona\n\nimport matplotlib.patches as mpatches\n\nimport warnings\nwarnings.filterwarnings(\"ignore\")\n\nfrom matplotlib.lines import Line2D\n\nfrom src.colors import *\n\ntp_leg = mpatches.Patch(color=colors9[1], label='True positives')\nfp_leg = mpatches.Patch(color=colors9[5], label='False positives')\nfn_leg = mpatches.Patch(color=colors9[4], label='False negatives')\nlhandles = [tp_leg, fp_leg, fn_leg]\n\nmodel_path = Path('../runs/yolov8m_Adam/fold_4')\nimage_path = Path('../data/rgb_mosaics/')\nresult_dir = Path('../results_l1c/yolov8m_Adam/fold_4')\nshp_path = Path('../dataset')\n\n\n\n\nCode\ndef get_tp_fp_fn(pred_gdf:gpd.GeoDataFrame, gt_gdf:gpd.GeoDataFrame, \n                 iou_threshold:float, area_limit:gpd.GeoDataFrame=None) -&gt; tuple[gpd.GeoDataFrame, gpd.GeoDataFrame, gpd.GeoDataFrame]:\n    \"\"\"\n    Derive true positives, false positives and false negatives\n\n    Args:\n        pred_gdf (geopandas.GeoDataFrame): Dataframe containing polygon predictions\n        gt_gdf (geopandas.GeoDataFrame): Dataframe containing ground truth polygons\n        iou_threshold (float): The intersection-over-union threshold to use for matching polygons.\n\n    Returns:\n        tuple: (tp, fp, fn) geodataframes containing the true positives, false positives and false negatives\n    \"\"\"\n\n    # Copy the dataframes to avoid modifying the originals\n    pred_gdf_copy = pred_gdf.copy()\n    gt_gdf_copy = gt_gdf.copy()\n    \n    if area_limit: # Clip to only contain some subarea\n        pred_gdf_copy = pred_gdf_copy.clip(area_limit)\n        gt_gdf_copy = gt_gdf_copy.clip(area_limit)\n    \n    # Count the number of true positives, false positives, and false negatives\n    true_positives = 0\n    false_positives = 0\n    false_negatives = 0\n\n    tp_ixs = []\n    fp_ixs = []\n    for index, pred_row in pred_gdf_copy.iterrows():\n        # Find the ground truth polygons that overlap with the prediction\n        overlapping_gts = gt_gdf_copy[gt_gdf_copy.geometry.intersects(pred_row.geometry)]\n        if overlapping_gts.empty:\n            false_positives += 1\n            fp_ixs.append(index)\n        else:\n            # Compute IoU between the prediction and overlapping ground truth polygons\n            ious = overlapping_gts.geometry.intersection(pred_row.geometry).area / overlapping_gts.geometry.union(pred_row.geometry).area\n\n            # Find the maximum IoU and corresponding index\n            max_iou = np.max(ious.values)\n            max_iou_index = np.argmax(ious.values)\n            # If the maximum IoU is greater than the threshold, it's a true positive\n            if max_iou &gt;= iou_threshold:\n                true_positives += 1\n                tp_ixs.append(index)\n                # Remove the matched ground truth polygon to avoid double counting\n                gt_gdf_copy.drop(overlapping_gts.index[max_iou_index], inplace=True)\n            else:\n                false_positives += 1\n                fp_ixs.append(index)\n\n    # Any remaining ground truth polygons are false negatives\n    false_negatives = gt_gdf_copy\n    # Compute precision and recall\n    return pred_gdf.iloc[tp_ixs], pred_gdf.iloc[fp_ixs], false_negatives\n\ndef evaluate(\n    ground_truth_path:Path, # Path containing the ground truth geopackages\n    result_dir:Path, # Path which contains the results\n    tile:str=None, # Optional tile_id to evaluate only\n    layer:str=None # Optional layer to evaluate only\n) -&gt; dict:\n    \"Evaluate detection results based on ground truth and corresponding results and return result dict.\"\n    yolo_aps = [[],[],[],[],[],[],[],[],[],[]]\n    yolo_precs =  [[],[],[],[],[],[],[],[],[],[]]\n    yolo_recs =  [[],[],[],[],[],[],[],[],[],[]]\n    ious = np.linspace(0.5, 0.95, 10)\n\n    if tile is None: tiles = os.listdir(result_dir)\n    else: tiles = [tile]\n    for ix, i in enumerate(ious):\n        tps_df = None\n        fps_df = None\n        tot_tp = 0\n        tot_fp = 0\n        tot_fn = 0\n        detmetrics = DetMetrics(names={1:'boat'})\n        for t in tiles:\n            if layer is None:\n                tsteps = fiona.listlayers(ground_truth_path/f'{t.split(\".\")[0]}.gpkg')\n            else:\n                tsteps = [layer]\n            for tstep in tsteps:\n                targs = gpd.read_file(ground_truth_path/f'{t}.gpkg', layer=tstep)\n                preds = gpd.read_file(result_dir/t/f'{tstep}.geojson')\n                tp, fp, fn = get_tp_fp_fn(preds, targs, i)\n                if tps_df is None: tps_df = tp\n                else: tps_df = pd.concat((tps_df, tp))\n                if fps_df is None: fps_df = fp\n                else: fps_df = pd.concat((fps_df, fp))\n                tot_tp += len(tp)\n                tot_fp += len(fp)\n                tot_fn += len(fn)\n        tp_ixs = np.ones((len(tps_df), 1))\n        fp_ixs = np.zeros((len(fps_df),1))\n        tps_for_yolo = np.concatenate((fp_ixs, tp_ixs))\n        confs_for_yolo = np.concatenate((fps_df.score, tps_df.score))\n        target_classes = np.ones_like(tps_for_yolo)[:,0]\n        pred_classes = np.ones_like(tps_for_yolo)[:,0]\n        detmetrics.process(tps_for_yolo, confs_for_yolo, target_classes, pred_classes)\n        yolo_aps[ix] = detmetrics.box.ap[0]\n        yolo_precs[ix] = tot_tp / (tot_tp + tot_fp)\n        yolo_recs[ix] = tot_tp / (tot_tp + tot_fn)\n    \n    outdict = {\n        'precision': yolo_precs[0],\n        'recall': yolo_recs[0],\n        'mAP50': yolo_aps[0],\n        'mAP50-95': np.mean(yolo_aps)\n    }\n\n    return outdict\n\n\nCompare the results for individual products acquired with the best individual model, YOLOv8m_fold4. True positives are defined based on IoU of predicted polygons using shapely.\n\n\nCode\nresults = evaluate(shp_path, result_dir)\nresults\n\n\n{'precision': 0.8588661037394452,\n 'recall': 0.8746928746928747,\n 'mAP50': 0.8801642478550638,\n 'mAP50-95': 0.4529611870353037}\n\n\n\nBothnian sea\n\n\nCode\narchi_image_dir = image_path/'34VEN'\narchi_files = os.listdir(archi_image_dir)\n#| label: fig-archi-test\n#| fig-cap: \"Archipelago sea\" \n\nfig, axs = plt.subplots(1,3, dpi=200, figsize=(10,5))\nfor t, a in zip(archi_files, axs):\n    a.axis('off')\n    with rio.open(archi_image_dir/t) as src:\n        rio_plot.show(src, ax=a)\n    a.set_title(f'{t[:-4]}')\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\nCode\nresults = evaluate(shp_path, result_dir, tile='34VEN')\nresults\n\n\n{'precision': 0.8760717069368668,\n 'recall': 0.8829536527886881,\n 'mAP50': 0.8982520526676592,\n 'mAP50-95': 0.46483866403107055}\n\n\nOverall, results in the Bothnian Sea were higher than in Kvarken\n\n\nCode\nresults = evaluate(shp_path, result_dir, tile='34VEN', layer=archi_files[0][:-4])\nfname = archi_files[0]\ntargs = gpd.read_file(shp_path/'34VEN.gpkg', layer=fname.split('.')[0])\npreds = gpd.read_file(result_dir/'34VEN'/fname.replace('tif', 'geojson'))\ntp, fp, fn = get_tp_fp_fn(preds, targs, 0.5)\nprint(f'Precision: {results[\"precision\"]}')\nprint(f'Recall: {results[\"recall\"]}')\nprint(f'mAP50: {results[\"mAP50\"]}')\nprint(f'mAP50-95: {results[\"mAP50-95\"]}')\n\nfig, ax = plt.subplots(1,1, dpi=150, figsize=(7,7))\nwith rio.open(archi_image_dir/fname) as src:\n    rio_plot.show(src, ax=ax)\ntp['geometry'] = tp.geometry.centroid\ntp.plot(ax=ax, color=colors9[1], markersize=.5)\nfp['geometry'] = fp.geometry.centroid\nfp.plot(ax=ax, color=colors9[5], markersize=.5)\nfn['geometry'] = fn.geometry.centroid\nfn.plot(ax=ax, color=colors9[4], markersize=.5)\nax.legend(handles=lhandles)\nplt.title(f'{len(tp)} TP, {len(fp)} FP, {len(fn)} FN') \nplt.show()\n\n\nPrecision: 0.8793859649122807\nRecall: 0.8911111111111111\nmAP50: 0.9048575439959524\nmAP50-95: 0.4549119284918774\n\n\n\n\n\n\n\n\n\n\n\nCode\nresults = evaluate(shp_path, result_dir, tile='34VEN', layer=archi_files[1][:-4])\nfname = archi_files[1]\ntargs = gpd.read_file(shp_path/'34VEN.gpkg', layer=fname.split('.')[0])\npreds = gpd.read_file(result_dir/'34VEN'/fname.replace('tif', 'geojson'))\ntp, fp, fn = get_tp_fp_fn(preds, targs, 0.5)\nprint(f'Precision: {results[\"precision\"]}')\nprint(f'Recall: {results[\"recall\"]}')\nprint(f'mAP50: {results[\"mAP50\"]}')\nprint(f'mAP50-95: {results[\"mAP50-95\"]}')\n\nfig, ax = plt.subplots(1,1, dpi=150, figsize=(7,7))\nwith rio.open(archi_image_dir/fname) as src:\n    rio_plot.show(src, ax=ax)\ntp['geometry'] = tp.geometry.centroid\ntp.plot(ax=ax, color=colors9[1], markersize=.5)\nfp['geometry'] = fp.geometry.centroid\nfp.plot(ax=ax, color=colors9[5], markersize=.5)\nfn['geometry'] = fn.geometry.centroid\nfn.plot(ax=ax, color=colors9[4], markersize=.5)\nax.legend(handles=lhandles)\nplt.title(f'{len(tp)} TP, {len(fp)} FP, {len(fn)} FN')\nplt.show()\n\n\nPrecision: 0.8557919621749409\nRecall: 0.8537735849056604\nmAP50: 0.8798468382164418\nmAP50-95: 0.45136345782934056\n\n\n\n\n\n\n\n\n\n\n\nCode\nresults = evaluate(shp_path, result_dir, tile='34VEN', layer=archi_files[2][:-4])\nfname = archi_files[2]\ntargs = gpd.read_file(shp_path/'34VEN.gpkg', layer=fname.split('.')[0])\npreds = gpd.read_file(result_dir/'34VEN'/fname.replace('tif', 'geojson'))\ntp, fp, fn = get_tp_fp_fn(preds, targs, 0.5)\nprint(f'Precision: {results[\"precision\"]}')\nprint(f'Recall: {results[\"recall\"]}')\nprint(f'mAP50: {results[\"mAP50\"]}')\nprint(f'mAP50-95: {results[\"mAP50-95\"]}')\n\nfig, ax = plt.subplots(1,1, dpi=150, figsize=(7,7))\nwith rio.open(archi_image_dir/fname) as src:\n    rio_plot.show(src, ax=ax)\ntp['geometry'] = tp.geometry.centroid\ntp.plot(ax=ax, color=colors9[1], markersize=.5)\nfp['geometry'] = fp.geometry.centroid\nfp.plot(ax=ax, color=colors9[5], markersize=.5)\nfn['geometry'] = fn.geometry.centroid\nfn.plot(ax=ax, color=colors9[4], markersize=.5)\nax.legend(handles=lhandles)\nplt.title(f'{len(tp)} TP, {len(fp)} FP, {len(fn)} FN')\nplt.show()\n\n\nPrecision: 0.8935643564356436\nRecall: 0.9047619047619048\nmAP50: 0.9133811417804785\nmAP50-95: 0.49604527401217924\n\n\n\n\n\n\n\n\n\n\n\nKvarken\n\n\nCode\nkva_image_dir = image_path/'34VER'\nkva_files = os.listdir(kva_image_dir)\n\n#| label: fig-archi-test\n#| fig-cap: \"Archipelago sea\" \n\nfig, axs = plt.subplots(1,3, dpi=200, figsize=(10,5))\nfor t, a in zip(kva_files, axs):\n    a.axis('off')\n    with rio.open(kva_image_dir/t) as src:\n        rio_plot.show(src, ax=a)\n    a.set_title(f'{t[:-4]}')\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\nCode\nresults = evaluate(shp_path, result_dir, tile='34VER')\nresults\n\n\n{'precision': 0.8,\n 'recall': 0.8450704225352113,\n 'mAP50': 0.8182644085749532,\n 'mAP50-95': 0.4158441741549826}\n\n\n\n\nCode\nresults = evaluate(shp_path, result_dir, tile='34VER', layer=kva_files[0][:-4])\nfname = kva_files[0]\ntargs = gpd.read_file(shp_path/'34VER.gpkg', layer=fname.split('.')[0])\npreds = gpd.read_file(result_dir/'34VER'/fname.replace('tif', 'geojson'))\ntp, fp, fn = get_tp_fp_fn(preds, targs, 0.5)\nprint(f'Precision: {results[\"precision\"]}')\nprint(f'Recall: {results[\"recall\"]}')\nprint(f'mAP50: {results[\"mAP50\"]}')\nprint(f'mAP50-95: {results[\"mAP50-95\"]}')\n\nfig, ax = plt.subplots(1,1, dpi=150, figsize=(7,7))\nwith rio.open(kva_image_dir/fname) as src:\n    rio_plot.show(src, ax=ax)\ntp['geometry'] = tp.geometry.centroid\ntp.plot(ax=ax, color=colors9[1], markersize=.5)\nfp['geometry'] = fp.geometry.centroid\nfp.plot(ax=ax, color=colors9[5], markersize=.5)\nfn['geometry'] = fn.geometry.centroid\nfn.plot(ax=ax, color=colors9[4], markersize=.5)\nax.legend(handles=lhandles)\nplt.title(f'{len(tp)} TP, {len(fp)} FP, {len(fn)} FN')\nplt.show()\n\n\nPrecision: 0.8048780487804879\nRecall: 0.7951807228915663\nmAP50: 0.8171052034281577\nmAP50-95: 0.4204982300338796\n\n\n\n\n\n\n\n\n\n\n\nCode\nresults = evaluate(shp_path, result_dir, tile='34VER', layer=kva_files[1][:-4])\nfname = kva_files[1]\ntargs = gpd.read_file(shp_path/'34VER.gpkg', layer=fname.split('.')[0])\npreds = gpd.read_file(result_dir/'34VER'/fname.replace('tif', 'geojson'))\ntp, fp, fn = get_tp_fp_fn(preds, targs, 0.5)\nprint(f'Precision: {results[\"precision\"]}')\nprint(f'Recall: {results[\"recall\"]}')\nprint(f'mAP50: {results[\"mAP50\"]}')\nprint(f'mAP50-95: {results[\"mAP50-95\"]}')\n\nfig, ax = plt.subplots(1,1, dpi=150, figsize=(7,7))\nwith rio.open(kva_image_dir/fname) as src:\n    rio_plot.show(src, ax=ax)\ntp['geometry'] = tp.geometry.centroid\ntp.plot(ax=ax, color=colors9[1], markersize=.5)\nfp['geometry'] = fp.geometry.centroid\nfp.plot(ax=ax, color=colors9[5], markersize=.5)\nfn['geometry'] = fn.geometry.centroid\nfn.plot(ax=ax, color=colors9[4], markersize=.5)\nax.legend(handles=lhandles)\nplt.title(f'{len(tp)} TP, {len(fp)} FP, {len(fn)} FN')\nplt.show()\n\n\nPrecision: 0.8186528497409327\nRecall: 0.8586956521739131\nmAP50: 0.8372617926152419\nmAP50-95: 0.42298120061016997\n\n\n\n\n\n\n\n\n\n\n\nCode\nresults = evaluate(shp_path, result_dir, tile='34VER', layer=kva_files[2][:-4])\nfname = kva_files[2]\ntargs = gpd.read_file(shp_path/'34VER.gpkg', layer=fname.split('.')[0])\npreds = gpd.read_file(result_dir/'34VER'/fname.replace('tif', 'geojson'))\ntp, fp, fn = get_tp_fp_fn(preds, targs, 0.5)\nprint(f'Precision: {results[\"precision\"]}')\nprint(f'Recall: {results[\"recall\"]}')\nprint(f'mAP50: {results[\"mAP50\"]}')\nprint(f'mAP50-95: {results[\"mAP50-95\"]}')\n\nfig, ax = plt.subplots(1,1, dpi=150, figsize=(7,7))\nwith rio.open(kva_image_dir/fname) as src:\n    rio_plot.show(src, ax=ax)\ntp['geometry'] = tp.geometry.centroid\ntp.plot(ax=ax, color=colors9[1], markersize=.5)\nfp['geometry'] = fp.geometry.centroid\nfp.plot(ax=ax, color=colors9[5], markersize=.5)\nfn['geometry'] = fn.geometry.centroid\nfn.plot(ax=ax, color=colors9[4], markersize=.5)\nax.legend(handles=lhandles)\nplt.title(f'{len(tp)} TP, {len(fp)} FP, {len(fn)} FN')\nplt.show()\n\n\nPrecision: 0.76\nRecall: 0.8636363636363636\nmAP50: 0.7924646431838238\nmAP50-95: 0.4130098298805803",
    "crumbs": [
      "Test scene analysis"
    ]
  },
  {
    "objectID": "data_creation-revision.html",
    "href": "data_creation-revision.html",
    "title": "Data creation",
    "section": "",
    "text": "Code\nimport warnings\nwarnings.filterwarnings(\"ignore\")\n\nimport rasterio as rio\nimport rasterio.plot as rio_plot\nimport matplotlib.pyplot as plt\nimport os\nfrom pathlib import Path\nimport numpy as np\nimport geopandas as gpd\nimport pandas as pd\nfrom shapely.geometry import Point\nimport shapely\nimport seaborn as sns\nfrom itertools import product",
    "crumbs": [
      "Data creation"
    ]
  },
  {
    "objectID": "data_creation-revision.html#train-and-validation-areas",
    "href": "data_creation-revision.html#train-and-validation-areas",
    "title": "Data creation",
    "section": "Train and validation areas",
    "text": "Train and validation areas\n\n\nCode\nfig, axs = plt.subplots(2,2, dpi=200, figsize=(10,10))\nfor t, a in zip(['20220515.tif', '20220619.tif','20220721.tif', '20220813.tif'], axs.flatten()):\n    a.axis('off')\n    with rio.open(image_path/'34VEM'/t) as src:\n        rio_plot.show(src, ax=a)\n    ships = gpd.read_file(shp_path/'34VEM.gpkg', layer=t.split('.')[0])\n    ships['geometry'] = ships.geometry.centroid\n    ships.plot(ax=a, color='red', markersize=.5)\n    n_ships = len(ships)\n    ships = None\n    a.set_title(f'{t[:-4]}: {n_ships} vessels')\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\nFigure 2: Archipelago sea\n\n\n\n\n\n\n\nCode\nfig, axs = plt.subplots(2,2, dpi=200, figsize=(10,10))\nfor t, a in zip(['20220606.tif','20220626.tif', '20220703.tif', '20220721.tif'], axs.flatten()):\n    a.axis('off')\n    with rio.open(image_path/'35VLG'/t) as src:\n        rio_plot.show(src, ax=a)\n    ships = gpd.read_file(shp_path/'35VLG.gpkg', layer=t.split('.')[0])\n    ships['geometry'] = ships.geometry.centroid\n    ships.plot(ax=a, color='red', markersize=.5)\n    n_ships = len(ships)\n    ships = None\n    a.set_title(f'{t[:-4]}: {n_ships} vessels')\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\nFigure 3: Gulf of Finland\n\n\n\n\n\n\n\nCode\nfig, axs = plt.subplots(1,3, dpi=200, figsize=(10,5))\nfor t, a in zip(['20220627.tif','20220712.tif', '20220828.tif'], axs):\n    a.axis('off')\n    with rio.open(image_path/'34WFT'/t) as src:\n        rio_plot.show(src, ax=a)\n    ships = gpd.read_file(shp_path/'34WFT.gpkg', layer=t.split('.')[0])\n    ships['geometry'] = ships.geometry.centroid\n    ships.plot(ax=a, color='red', markersize=.5)\n    n_ships = len(ships)\n    ships = None\n    a.set_title(f'{t[:-4]}: {n_ships} vessels')\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\nFigure 4: Bothnian bay",
    "crumbs": [
      "Data creation"
    ]
  },
  {
    "objectID": "data_creation-revision.html#test-areas",
    "href": "data_creation-revision.html#test-areas",
    "title": "Data creation",
    "section": "Test areas",
    "text": "Test areas\n\n\nCode\nfig, axs = plt.subplots(2,2, dpi=200, figsize=(10,10))\nfor t, a in zip(['20210714.tif', '20220619.tif', '20220624.tif', '20220813.tif'], axs.flatten()):\n    a.axis('off')\n    with rio.open(image_path/'34VEN'/t) as src:\n        rio_plot.show(src, ax=a)\n    ships = gpd.read_file(shp_path/'34VEN.gpkg', layer=t.split('.')[0])\n    ships['geometry'] = ships.geometry.centroid\n    ships.plot(ax=a, color='red', markersize=.5)\n    n_ships = len(ships)\n    ships = None\n    a.set_title(f'{t[:-4]}: {n_ships} vessels')\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\nFigure 5: Bothnian sea\n\n\n\n\n\n\n\nCode\nfig, axs = plt.subplots(1,3, dpi=200, figsize=(10,5))\nfor t, a in zip(['20220617.tif', '20220712.tif', '20220826.tif'], axs):\n    a.axis('off')\n    with rio.open(image_path/'34VER'/t) as src:\n        rio_plot.show(src, ax=a)\n    ships = gpd.read_file(shp_path/'34VER.gpkg', layer=t.split('.')[0])\n    ships['geometry'] = ships.geometry.centroid\n    ships.plot(ax=a, color='red', markersize=.5)\n    n_ships = len(ships)\n    ships = None\n    a.set_title(f'{t[:-4]}: {n_ships} vessels')\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\nFigure 6: Kvarken",
    "crumbs": [
      "Data creation"
    ]
  },
  {
    "objectID": "data_creation-revision.html#bounding-box-area",
    "href": "data_creation-revision.html#bounding-box-area",
    "title": "Data creation",
    "section": "Bounding box area",
    "text": "Bounding box area\nAs most of the annotations cover also most of the wake of the marine vessel, the bounding boxes are significantly larger than a typical boat. There are a few annotations larger than 100 000 m², which are either cruise or cargo ships that are travelling along ordinal directions instead of cardinal directions, instead of e.g. smaller leisure boats.\n\n\nCode\nall_ships.bbox_area.describe()\n\n\ncount      8866.000000\nmean       5167.597207\nstd       10840.414965\nmin         567.880229\n25%        1567.112875\n50%        2266.456435\n75%        4970.987639\nmax      414795.692722\nName: bbox_area, dtype: float64",
    "crumbs": [
      "Data creation"
    ]
  },
  {
    "objectID": "data_creation-revision.html#diameter",
    "href": "data_creation-revision.html#diameter",
    "title": "Data creation",
    "section": "Diameter",
    "text": "Diameter\nAnnotations typically have diameter less than 100 meters, and the largest diameters correspond to similar instances than the largest bounding box areas.\n\n\nCode\nall_ships.diam.describe()\n\n\ncount    8866.000000\nmean       91.045323\nstd        58.957569\nmin        33.721374\n25%        56.718731\n50%        68.382853\n75%       105.899522\nmax       913.890413\nName: diam, dtype: float64",
    "crumbs": [
      "Data creation"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Detecting marine vessels from Sentinel-2 imagery using YOLOv8",
    "section": "",
    "text": "Abstract\n\nIdentifying where maritime activities take place, and quantifying their potential impact on marine biodiversity, is important for sustainable management of marine areas, spatial planning and marine conservation. Detection and monitoring of small vessels, such as pleasure crafts, has been challenging due to limited data availability with adequate temporal and spatial resolution. Here, we develop an analysis framework to detect and quantify small vessels, using openly available Sentinel-2 optical imagery, and the YOLO-family object detection models. We also show how existing spatial datasets can be used to improve the quality of the model output.\n\n\nWe chose five distinct marine areas along the Finnish coast in the northern Baltic Sea, and manually annotated 8,768 vessels for training and validating object detection models. The top-performing model, based on F1-score, achieved a test set F1-score of 0.863, and an mAP50 of 0.888. This model was then used to quantify pleasure crafts in the southern part of Finland from May to September 2022, using all available Sentinel-2 images with sufficient image quality. Detected recreational traffic was primarily concentrated on boating lanes and close to marinas, with weekend traffic averaging approximately twice the volume of weekday traffic.\n\n\nThe developed approach can identify areas with high boat traffic, supporting spatial planning, ecological impact avoidance, and serving as an indicator of recreational popularity of marine areas. Additionally, it provides a basis for assessing the potential impacts of pleasure crafts on marine biodiversity. By leveraging openly available satellite images with frequent revisits, the approach offers broad geographical coverage and high spatial accuracy, making it scalable for estimating boat traffic across large areas to support sustainable management and use of marine areas, even globally.\n\nUpdate to latest version is in progress.\n\n\nDemo application\nDemo application is running on Huggingface Spaces: https://huggingface.co/spaces/mayrajeo/marine-vessel-detection.\n\n\nAuthors\n\nJanne Mäyrä, Finnish Environment Institute (Syke)\nElina A. Virtanen, Syke\nAri-Pekka Jokinen, Syke\nJoni Koskikala, Marine Conservation, Parks and Wildlife, Finland\nSakari Väkevä, Syke\nJenni Attila, Syke\n\n\n\nAcknowledgments\nThis study was supported by Enhancing the marine and coastal biodiversity of the Baltic Sea in Finland and promoting the sustainable use of marine resources (LIFE-IP BIODIVERSEA (LIFE20 IPE/FI/000020)).\nThe authors wish to acknowledge CSC – IT Center for Science, Finland, for computational resources.",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "detection_results.html",
    "href": "detection_results.html",
    "title": "Detection results",
    "section": "",
    "text": "Code\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport pandas as pd\nimport geopandas as gpd\nfrom pathlib import Path\nimport os\nimport numpy as np\nimport fiona \nimport json\nimport warnings\nwarnings.filterwarnings(\"ignore\")\n\nimport sys\nsys.path.insert(1, '..')\nfrom src.colors import *\n\nmodel_path = Path('../runs_2023')",
    "crumbs": [
      "Detection results"
    ]
  },
  {
    "objectID": "detection_results.html#visual-comparisation-of-results",
    "href": "detection_results.html#visual-comparisation-of-results",
    "title": "Detection results",
    "section": "Visual comparisation of results",
    "text": "Visual comparisation of results\n\n\n\n\n\n\n\n\nFigure 2: Example result comparison for different models",
    "crumbs": [
      "Detection results"
    ]
  }
]